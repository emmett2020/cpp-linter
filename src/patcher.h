#pragma once

#include <format>
#include <stdexcept>
#include <string>
#include <string_view>
#include <unordered_map>
#include <vector>

namespace linter {

/// A module to contain the abstractions about creating suggestions from a diff
/// generated by the clang tool's output.

// A data structure to contain information about a single suggestion.

struct Suggestion {
  // TODO: maybe string or JSON?
  // Serialize this object into a JSON compatible with Github's REST API.
  // std::unordered_map<std::string, std::string>
  std::string serialize_to_github_payload() const {
    if (line_start == -1) {
      throw std::runtime_error{"Start line number unknown"};
    }
    if (line_end == -1) {
      throw std::runtime_error{"End line number unknown"};
    }
  }

  // The file's path about the suggested change.
  std::string file_name;

  // The markdown comment about the suggestion.
  std::string markdown_comment;

  // The file's line number starting the suggested change.
  std::size_t line_start = -1;

  // The file's line number ending the suggested change.
  std::size_t line_end = -1;

  bool operator<=>(const Suggestion &other) const {
    return other.file_name == file_name && other.line_start == line_start &&
           other.line_end == line_end;
  }
};

// A data structure to contain PR review comments from a specific clang tool.
struct ReviewComments {
  //
  std::vector<Suggestion> suggestions;
  std::unordered_map<std::string, int> tool_total{{"clang-tidy", 0},
                                                  {"clang-format", 0}};

  bool MergeSimilarSuggestion(const Suggestion &suggestion) {
    // merge a diven suggestion into a similar Suggetion
    // returns True if the suggestion was merged, otherwise False.

    for (auto &known : suggestions) {
      if (known == suggestion) {
        auto new_str = std::format("\n{}", suggestion.markdown_comment);
        known.markdown_comment += new_str;
        return true;
      }
    }
    return false;
  }

  std::unordered_map<std::string, std::string>
  serialize_to_github_payload(std::string_view clang_tidy_version,
                              std::string_view clang_format_version) {
    std::string summary;
    std::string comments;
    auto posted_tool_advice = std::unordered_map<std::string, int>{
        {"clang-tidy", 0},
        {"clang-format", 0},
    };

    for (const auto &comment : suggestions) {
      comments += comment.serialize_to_github_payload();
      if (comment.markdown_comment.contains("### clang-format")) {
        ++posted_tool_advice["clang-format"];
      }
      if (comment.markdown_comment.contains("### clang-tidy")) {
        ++posted_tool_advice["clang-tidy"];
      }
    }

    const std::array<std::string, 2> tools{"clang-tidy", "clang-format"};
    for (const auto tool_name : tools) {
      auto tool_version =
          tool_name == "clang-tidy" ? clang_tidy_version : clang_format_version;

      // There is no tool version
      if (tool_version == "") {
        continue;
      }
      if (comments.size() > 0 &&
          posted_tool_advice[tool_name] != tool_total[tool_name]) {
        summary += std::format("Only {} out of {} {} concerns fit within this "
                               "pull request's diff.\n",
                               posted_tool_advice[tool_name],
                               tool_total[tool_name], tool_name);
      }

      summary +=
          std::format("\n<details><summary>Click here for the full {} patch "
                      "<summary>\n\n\n```diff\n{}\n```\n\n\n<details>\n\n",
                      tool_name, tool_name);
      return {summary, comments};
    }
  }
};

} // namespace linter
